                                         Angular 
...............................................................................................
DOM:
....
Component:

 -Component is object,UI Object.
 -Component is core object without which no ui
 -Component uses other objects-directives,services,pipes,so....

At core,At very low level- 
  Component is simple javascript function.
  
  function has logic to create "DOM ELEMENT/DOM MANIUPLATION"

DOM: 
   DOM is spec , defined by W3C to reprenent html elements inside javascript engine.


HTML;
  HTML is programming language -  dsl pl /declarative pl.

HTML internal work flow:
........................

index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>

feed into-------------------Browser

loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
.........................................................................................
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body

|
-------------------------Execution cycle------------------------------------
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList

body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body
| 
 Linking the Nodes: Tree
body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
 |
 |
  Layout/Paint Engine: will convert nodes into pxs : final output
//////////////////////////////////////////////////////////////////////////////////////////////

Birth of Javascript:
...................

At Netscap decided to modifiy the linked list / tree via special program 

netscap decided to create very light weight programming language to access the tree and modify the tree at runtime - js

/////////////////////////////////////////////////////////////////////////////////////////////


class OrderComponent {}


let cmp = new OrderComponent() ; In angular we dont need to create OrderComponent Object
Angular creates on behalf of us  - Dependency Injection System.

...........................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////

					HTML Elements types

1.built in elements

2.custom elements


1.built in elements
  are part of html language spec
 h1,body,p,nav,div,script,li,img.......


int a =10; - compiler---compile---assembly code

Int a =10; -compiler --|

compiler design

 source code
                              compiler db -[div]
                                 |
  <div></div> ----- compile----compiler
                                  |
                      ------------------------
                    if present             
                      |
                    execution
                      |
                     node
                       |
                     screen


                                compiler db -[Subramanian]
                                    |
  <subramanian></subramaian> ----- compile----compiler
                                  |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              throw error - UnKnown Element
                      |                                 |
                     node                              Convert that element into PlanText   
                       |                               |
                     screen                           render



2.IN 2007-2008 W3C Decided to introduce new html spec - html 5

 -custom elements - how to add new elements
 -custom attributes - how to add custom attribues on existing html specs

Custom Types
int,float =  class A{ int,float }

how to teach browser to understand custom elements and attributes
   -via Javascript


                             compiler db -[Subramanian]
                                    |
 <subramanian></subramaian> ----- compile----compiler
                                  |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              feed into js 
                      |                                 |
                     node                              js will do something   
                       |                               |
                     screen                           render



eg:

class AppDrawer extends HTMLElement {...}

window.customElements.define('app-drawer', AppDrawer);

// Or use an anonymous class if you don't want a named constructor in current scope.
window.customElements.define('app-drawer', class extends HTMLElement {...});



  			              compiler db -[div,Subramanian]
                                           |
<subramanian></subramaian> --jsengine will add new defintion--- compile----compiler
                                   |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              throw error - UnKnown Element
                      |                                 |
                     node                              Convert that element into PlanText   
                       |                               |
                     screen                           render

////////////////////////////////////////////////////////////////////////////////////////////
Angular and Custom Elements:

 Angular follows custom element spec in order to create apps.


  Custom Element
  <app-root></app-root>
                  |
                  ------------->|import { Component } from '@angular/core';

				@Component({
 				 selector: 'app-root',
  				templateUrl: './app.component.html',
  				styleUrls: ['./app.component.css']
				})
				export class AppComponent {
					  title = 'ng-helloworld';
				}


<app-root></app-root> ---------------function AppComponent(){ 
                                           //dom code
                                     }


/////////////////////////////////////////////////////////////////////////////////////////////


Modules

code organization.

Physcial code -  es 6 modules - export,import

organization  ,folders, and files

src
 services
   order.service.ts

code organization 
 logical organzation.
Object organization- runtime.
modules are logical representation which organzies other objects


Angular application organization into modules(container)

Types of containers

-main container - main module
-sub container - sub modules

Every angular must have one single main module /app module

Types of modules:

1.Built in modules : angular provides lot of submodules
2.Programmer defined modules -  ordermodules,customermodule,productmodules


-main container - main module

Every thing is object?


How objects are created?

 out of classes

you need class.

@NgModule()
class AppModule {}

Who is creating object?

Angular framework injector system.

 let module = new AppModule();


Infra objects and decoarators


module    ---- @NgModule
component -----@Component
Directive ----@Directive
Pipe     ----- @Pipe
Servie  -------@Injectable

@NgModule()
export class AppModule {}

@Comoponent()
export class AppComponent {}


@Injectable()
export class OrderService {}


@Pipe()
export class SortPipe {}


@Directive()
export class SortPipe {}
..............................................................................................

Exploring App Component:

Angular Built in decorators


Angular supports lot of built in decorators.

 Component ContentChild ContentChildren Directive Host HostBinding HostListener Inject Injectable Input NgModule Optional Output Pipe Self SkipSelf ViewChild ViewChildren


@Component Decorators is core decorator used to create component object.
@Component decorator is child decorator of @Directive.

Component decorator takes parameter which is called "Meta Object".

@Component({})


app.component.ts
import { Component } from "@angular/core";



@Component({
  selector: 'app-root', // custom element,
  //template : inline : part of component declaration
  // template : `
  //     <h1>Welcome to Angualr</h1>   
  // `
  templateUrl: 'app.component.html'
  
})
export class AppComponent { }
............................................................................................

//
object creations

 let app = new AppComponent()

in angular we dont create infra objects- angular create automatically.

   injector system.


how to tell angular to create objects.

Angular never creates objects until you tell -  you configure.

Angular creates infra objects only. via decorator.

Even though angular uses infra objects, never creates them until you tell.

Where you can tell?

 inside another object called "Module" - AppModule.


1.DI INFO : object creation information

Infra objects can be classified into three category:
......................................................

1.1.view Objects
 components,directives,pipes
 declarations:[]
  declarations: [AppComponent], // view objects - component,pipe,directives

1.2.module objects-submodules
  imports: [BrowserModule], //all sub modules

1.3.services/providers
  providers: []


Where you can tell?

 inside another object called "Module" - AppModule.


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Coding Best practice:

<app-root> 
  ? - ?
tag name:
Do use dashed-case or kebab-case for naming the element selectors of components.

can i use different name

<ibm-root>
  yes
before you use, we need to configure it in angular.json files

"prefix": "ibm"

file names:

domainname.component/service/directive/pipe/module /.spec.ts/html/css

hero.component.ts|html|css|spec
hero.service.ts
hero.directive.ts
hero.pipe.ts

hero.component.ts
hero.component.css
hero.component.html

app.component.ts
app.component.html
app.component.css
app.component.spec.ts - unit testing file


class Names

-Do use upper camel case for class names.  - Order
-Do match the name of the symbol to the name of the file.
-Do append the symbol name with the conventional suffix x (such as Component, Directive, Module, Pipe, or Service) for a thing of that type.
   CustomerComponent, CustomerService, CustomerDirective CustomerPipe ..

Do give the filename the conventional suffix (such as .component.ts, .directive.ts, .module.ts, .pipe.ts, or .service.ts) for a file of that type.

   customer.component.ts    ----export class CustomerComponent { }
   customer.module.ts        ----export class CustomerModule {}
   customer.pipe.ts          -----export class CustomerPipe {}
   etc...
.............................................................................................

modularaization:

1.break app into files and folders

app - main folder -  only root files - module,component
 |
 greeter
 customer
 product
 utils
 services
 directives
 pipes

Component driven arch:

 as much as possible we have break component ; 


Angular dev tool

///////////////////////////////////////////////////////////////////////////////////////////

How to create a component and use it?


HTML View
<body>
  <app-root>
	 <app-hello></app-hello>
	 <app-hai></app-hai>
  </app-root>
</body>

app/greeter/hello.component.ts
import { Component } from "@angular/core";


@Component({
    selector:'app-hai',
    templateUrl: 'hai.component.html'
})
export class HaiComponent{

}

app/greeter/hello.component.html
<h1>Hello Component</h1>


app/greeter/hai.component.html
<h1>Hai Component</h1>

app/greeter/hai.component.ts
import { Component } from "@angular/core";


@Component({
    selector:'app-hai',
    templateUrl: 'hai.component.html'
})
export class HaiComponent{

}

app.module.ts
import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { AppComponent } from "./app.component";
import { HaiComponent } from "./greeter/hai.component";
import { HelloComponent } from "./greeter/hello.component";



@NgModule({
  declarations: [AppComponent,HelloComponent,HaiComponent],  //View Objects
  imports: [BrowserModule],  //All SubModule
  providers: [],   //Services,
  bootstrap: [AppComponent]
})
export class AppModule { }

app.component.html
<h1>Welcome to Angular !!!</h1>
<app-hello></app-hello>
<app-hai></app-hai>

....................................................................................

<body>
  <app-root>
         <app-greeter>
		 <app-hello></app-hello>
		 <app-hai></app-hai>
  	 </app-greeter>
  </app-root>
</body>

app/greeter/greeter.component.ts
import { Component } from "@angular/core";



@Component({
    selector: 'app-greeter',
    templateUrl:'greeter.component.html'
})
export class GreeterComponent{

}
app/greeter/greeter.component.html
<app-hello></app-hello>
<app-hai></app-hai>


app.component.html
<h1>Welcome to Angular !!!</h1>
<app-greeter></app-greeter>

import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { AppComponent } from "./app.component";
import { GreeterComponent } from "./greeter/greeter.component";
import { HaiComponent } from "./greeter/hai.component";
import { HelloComponent } from "./greeter/hello.component";



@NgModule({
  declarations: [AppComponent,HelloComponent,HaiComponent,GreeterComponent],  //View Objects
  imports: [BrowserModule],  //All SubModule
  providers: [],   //Services,
  bootstrap: [AppComponent]
})
export class AppModule { }
/////////////////////////////////////////////////////////////////////////////////////////////

Angular Dev Tool:

 To visuize the component arch in browser

..........................................................................................

Modularity:

->Phsyical modularity -  files and folders 
  sharing coding via export and import.
->Logical Modularity
  Organzation of objects(comp,services...).

SubModule:
 It is container object we need to organize objects.
 

app/greeter.module.ts
import { NgModule } from "@angular/core";
import { GreeterComponent } from "./greeter.component";
import { HaiComponent } from "./hai.component";
import { HelloComponent } from "./hello.component";



@NgModule({
    declarations:[GreeterComponent,HelloComponent,HaiComponent],
    imports:[],
    providers:[]
})
export class GreeterModule {}


app.module.ts

import { GreeterModule } from "./greeter/greeter.module";

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule,GreeterModule],  //All SubModules
  providers: [],   //Services,
  bootstrap: [AppComponent]
})
export class AppModule { }


After that you can see error


rror: src/app/app.component.html:4:1 - error NG8001: 'app-greeter' is not a known element:     1. If 'app-greeter' is an Angular component, then verify that it is part of this module.       2. If 'app-greeter' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.                                                                                                                                                                                                                4 <app-greeter></app-greeter>                                                                                         

Module Scope:
Any Component,Pipe,Directive,submodule refers inside a module will be available inside that module only. Module Scope


Module Scope:

1.public scope
   if any objects belong to all modules that  is public
2.private scope
  if any objects belong to that module is private including appmodule.

if you want to make any object in public scope, you need to configer it
exports: 


@NgModule({
    declarations: [GreeterComponent, HelloComponent, HaiComponent,WeclomeComponent],
    imports: [],
    providers: [],
    exports:[GreeterComponent]
})
export class GreeterModule {

}

import { NgModule } from "@angular/core";
import { GreeterComponent } from "./greeter.component";
import { HaiComponent } from "./hai.component";
import { HelloComponent } from "./hello.component";



@NgModule({
    declarations:[GreeterComponent,HelloComponent,HaiComponent],
    imports:[],
    providers:[],
    exports:[GreeterComponent]
})
export class GreeterModule {}
............................................................................................

Problems in the dev flow:

Tasks:

1.create folder
2.create files - component-ts,html,css,spec
3.create module
4.declare class -cmp,service...
5.refer the classes inside module
6.you need to inject submodule into main module..

if you repeate the same thing for every object , which increases lot of time.

Automation:
 code generation automation

angular cli tool to generate code.


//create folder, create module, inject this module into app module
helloworld>ng g m header --module=app
CREATE src/app/header/header.module.ts (192 bytes)
UPDATE src/app/app.module.ts (756 bytes)  


create component, inside header folder, inject into header module, make it available public
i dont want css file,i want html file,i dontwant spec file

ng g c header/header  --flat=true --export=true --inline-style=true --skip-tests=true   --module=header


 --flat=true :  create any thing inside exsiting folder
 --export=true : make it public
 --inline-style=true : i dont want css file
 --skip-tests=true  :dont create spec files
 --module=header  : inject inside header module


>ng g c header/header --flat=true --export=true --inline-style=true --skip-tests=true --module=header
CREATE src/app/header/header.component.html (21 bytes)
CREATE src/app/header/header.component.ts (251 bytes)
UPDATE src/app/header/header.module.ts (307 bytes)

...........................................................................................
					Dyanamic Userinterface
					Data binding
............................................................................................


Data binding:
 Transfering state to ui(view)

Types of databinding

1.interpolation
2.property binding
3.attribute binding
4.event binding
5.two way data binding
6.class binding
7.style binding


1.interpolation:

MVC design pattern

Angular implements MVC design pattern.

M -Model data
V - View - Component Template
C - Controller - Component

COntroller transfer data to View.

Model- primitives,objects, arrays

src/app/interpolation/interpolation.component.ts
import { Component, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-interploation',
  templateUrl: './interploation.component.html',
  styles: [
  ]
})
export class InterploationComponent implements OnInit {

  //state/model/data
  name: string = "Subramanian Murugan"
  salary: number = 10000
  isValid: boolean = true;

  //object
  address: Address = {
    doorno: 10,
    city: 'Coimbatore'
  }

  //array
  skills: Array<string> = ["Angular", "Typescript", "Javascript", "MicroServices"];

  constructor() { }

  ngOnInit(): void {
  }

}
src/app/interpolation/interpolation.component.html
<h2>InterPolation</h2>
<h3>String(Name) :  {{name}}</h3>
<h3>Number(Salary) :  {{salary}}</h3>
<h3>Boolean(Valid) :  {{isValid ? "Valid" : "Invalid"}}</h3>
<h3>Object {{address.city}} {{address.doorno}}</h3>
<h3>Array</h3>
<p>Skill List</p>
<ul>
    <li *ngFor="let skill of skills" >
        <span>{{skill}}</span>
    </li>
</ul>
............................................................................................
                                Property Binding
............................................................................................


Property:[]


<img src="imglocation" />

What is src?
 src is attribute / property

attribute and property are synonmous

In Angular 
attribute means "property of html built in elements"

<img src="imglocation" />
   src is attribute

property means  "property of custom elements"

<app-greeter [message]="Hello"  >

message is property
............................................................................................

    "Where ever you use [], you can understand that the element can have dynamic values"

	  To the Component you can pass value via attribute/property dynamically


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attributebinding',
  templateUrl: './attributebinding.component.html',
  styles: [
  ]
})
export class AttributebindingComponent implements OnInit {

  //img location
  imgLocation: string = "favicon.ico";
  isEnabled:boolean = true;

  constructor() { }

  ngOnInit(): void {
  }

}
<h2>Attribute Binding</h2>
<h2>Static Attribute</h2>
<img src="favicon.ico"/>
<h2>Dynamic Attribute - []</h2>
<img [src]="imgLocation"/>
<div>
    <button [disabled]="isEnabled">Show Me</button>
</div>
...........................................................................................

Property Binding:

 passing data to custom elements/to component via property


property value can be any type - string,number,object,array

property value can be hardcoded or can be passed via variable

<app-greeter [message]="'Hello'" ></app-greeter> - hardcoded string value

<app-greeter [message]="variable" ></app-greeter> - hardcoded string value


Component and Property driven design :

  "As much as possible , we have to break the component and pass data"

.............................................................................................

Complex Binding : refere code:
.............................................................................................
					Styling
............................................................................................

CSS :

1.Global css

2.third party css
 bootstrap
npm install bootstrap --save

angular.json
    "styles": [
              "./node_modules/bootstrap/dist/css/bootstrap.css",
              "src/styles.css"
            ],

3.inside component
  styles: []  -component specific styles
   -inline
   -external
............................................................................................
					Event Binding
.............................................................................................
	

EventTarget Object: Event
  It connects dom object and listner method.
  where listener method can read values and other proproperties of dom object.

btn.addEventListener = function(evt){
  evt.target   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way binding:

-data is transfered from view to controller and controller to view 

How to implement two way data binding

1.events

///////////////////////////////////////////////////////////////////////////////////////////

Interaction with UI: Event Binding: ()

DOM events:

<button (click)="listner" >Click</button>

EventTarget Object:
  It connects dom object and listner method.
  where listener method can read values and other proproperties of dom object.

btn.addEventListener = function(evt){
   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way data binding:
when ever data is transfered from the ui , controller is notified, whenever controller updates the data,ui is notified

Two way data binding is achvied via 

 $event ----instance variable

.............................................................................................

<div>
    <h2>Click Event</h2>
    <button (click)="onClick()">Click</button>
</div>
<div>
    <h2>Input Event</h2>
    <div>
        <h3>With Listener</h3>
        <h3>{{inputMessage}}</h3>
        <input (input)="onRead($event)">
    </div>
    <div>
        <h3>Without Listener</h3>
        <h3>{{messageOne}}</h3>
        <input (input)="messageOne=$event.target.value">
    </div>

    <div>
        <h3>Property Binding + Event Binding </h3>
        <h3>{{messageTwo}}</h3>
        <input  [value]="messageTwo" (input)="messageTwo=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding = Banana Box Notation [()] </h3>
        <h3>{{messageThree}}</h3>
        <input [(ngModel)]="messageThree">
    </div>

</div>

............................................................................................

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dom-event-binding',
  templateUrl: './dom-event-binding.component.html',
  styles: [
  ]
})
export class DomEventBindingComponent implements OnInit {

  inputMessage: string = "..."

  messageOne:string="....";

  messageTwo:string="....";

  messageThree:string="....";

  constructor() { }

  onClick() {
    alert('Button was clicked')
  }
  onRead(evt: any) {
    //  console.log(evt.target.value)
    this.inputMessage = evt.target.value
  }
  ngOnInit(): void {
  }

}
//////////////////////////////////////////////////////////////////////////////////////////////
					Custom Events
.............................................................................................

Types of events:

1.dom events - click,input,keypress.......
2.custom events - events for custom elements

Why custom events?

Component communcation:

1.parent to child - via props pattern
2.child to parent - via custom events
3.across components -  via services


2.child to parent - via custom events



Steps : write two components

1.parent
2.child


Parent

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styles: [
  ]
})
export class ParentComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

2.Child Component

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styles: [
  ]
})
export class ChildComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

Step 2:

 EventEmitter:

Use in components with the @Output directive to emit custom events synchronously or asynchronously, and register handlers for those events by subscribing to an instance.

1.EventEmitter is used to broad cast values to Parent Components

class EventEmitter<T> extends Subject {
  constructor(isAsync?: boolean): EventEmitter<T>
  emit(value?: T): void
  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription
}

2.EventEmitter object is Subclass Rxjs Subject.

create EventEmitter Object of type in child compoent.

eventemitter is used to send custom events.

   onSendRequest = new EventEmitter<string>();

3.We have to decorate eventemitter with @Output()

  @Output()
  onSendRequest = new EventEmitter<string>();

4.send data to Parent Component

    <div>
        <input [(ngModel)]="message">
    </div>
    <div>
        <button (click)="onSend()">Send To Parent</button>
    </div>

export class ChildComponent {

  message: string = "Good Value"
  //event emitter Declaration
  @Output()
  onSendRequest = new EventEmitter<string>();
  onSend() {
    alert('sending data to parent')
    //emit data  -  next method in subject
    this.onSendRequest.emit(this.message)
  }

}

5.Listens event and grab the data from the Child

<div>
    <h1 style="text-align: center;">Parent Component</h1>
    <h2>{{childMessage}}</h2>
</div>
<hr/>
<app-child (onSendRequest)="onReadData($event)" ></app-child>


export class ParentComponent {

  childMessage: string;

  onReadData(event: any) {
    this.childMessage = event
  }

}

/////////////

final code :

Child:
<div>
    <h1 style="text-align: center;">Child Component</h1>
    <div>
        <input [(ngModel)]="message">
    </div>
    <div>
        <button (click)="onSend()">Send To Parent</button>
    </div>
</div>


export class ChildComponent implements OnInit {

  message: string = "Good Value"
  //event emitter Declaration
  @Output()
  onSendRequest = new EventEmitter<string>();

  constructor() { }

  ngOnInit(): void {
  }
  onSend() {
    alert('sending data to parent')
    //emit data  -  next method in subject
    this.onSendRequest.emit(this.message)
  }

}


Parent:

<div>
    <h1 style="text-align: center;">Parent Component</h1>
    <h2>{{childMessage}}</h2>
</div>
<hr/>
<app-child (onSendRequest)="onReadData($event)" ></app-child>

export class ParentComponent {

  childMessage: string;
  onReadData(event: any) {
    this.childMessage = event
  }

}
..............................................................................................
				 Pipes
..............................................................................................

What is pipe?
 pipe object used for data formating.

eg:
 show uppercase
 show money values - $,#,
 show date fromate  - 1/10/2021 , feb 10 2021...
 custom formates

Angular provides lot of built in pipes, you can write your own pipes as well.
....
Syntax:
  some data | nameof the pipe.


Builtin pipes:

DatePipe: Formats a date value according to locale rules.

UpperCasePipe: Transforms text to all upper case.

LowerCasePipe: Transforms text to all lower case.

CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.

DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.

PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.

asyncPipe : to bind list of values async


Date Formating:

today:any = new Date();

<h3>Today {{today | date }}</h3>

What if i want to customize date according our need?

 dd/mm/yyy - format

Pipes can take input

 {{expression | pipe:input}}


Custom Pipes:
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'decimalFraction'
})
export class DecimalFractionPipe implements PipeTransform {

  transform(value: number, numberofDigits: number = 2): any {
    console.log(value, numberofDigits)
    return value.toFixed(numberofDigits)
  }

}

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PipesComponent } from './pipes.component';
import { DecimalFractionPipe } from './decimal-fraction.pipe';



@NgModule({
  declarations: [
    PipesComponent,
    DecimalFractionPipe
  ],
  imports: [
    CommonModule
  ],
  exports: [
    PipesComponent,
    DecimalFractionPipe
  ]
})
export class PipesModule { }


pipes.component.html
<h2>Pipes</h2>
<h2>Date Pipe</h2>
{{today | date}}
{{today | date:'dd/MM/yyyy'}}
<p>The time is {{today | date:'h:mm a z'}}</p>
<h2>String Pipes</h2>
<p>name {{name | uppercase}} {{name | lowercase}}  {{name | titlecase}}</p>
<h2>Currency Pipes</h2>
<p>Stock Price  {{stockValue | currency}} {{stockValue | currency:'INR'}}</p>
<h2>Custom Pipe: DecimalFractionPipe</h2>
<p>Stock Value: {{stockValue | decimalFraction}}</p>
<p>Stock Value: {{stockValue | decimalFraction:3}}</p>


pipes.component.ts
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-pipes',
  templateUrl: './pipes.component.html',
  styles: [
  ]
})
export class PipesComponent implements OnInit {

  today = new Date();
  name:string = "subramanian"
  stockValue:number =1000.78675
  constructor() { }

  ngOnInit(): void {
  }

}
............................................................................................
					Directives
...........................................................................................

What is directive?
  Directive is custom element / attribute..

<app-root> ,<app-root [title]>


Types of Directives:
1.Template directive
2.Structural directive
3.Attribute directive



1.Template directive
   The directive with Template ; all components create template directive
  <app-root> ----------------template directive
  <app-profile>--------------template directive

All component's meta data is inherited from Directive meta.
Directive is parent , Component is child

Every component is directive.


2.Structural Directive
   It is type of directive, used to change HTML Layouts.
   They shape or reshape the DOM's "Structure" typically by adding,removing and manipulating
   the host elements to which they attached.
   
  -Host element means html elements eg div,span,li,table.
  -It is one of the "special attribute" directive
  -All structural directive starts with "*" notation.


Built in structural directives

1.*ngFor : for loop
2.*ngIf  : if condition
3.*ngSwitch : switch

List /Array rendering:
......................

Layouts:
1.List view Layout
   -ul li
2.Card View Layout
  div
3.Grid View Layout
  table tr td


1.for Loop: *ngFor

-where ever you want to repeate elements

element could be dom element or custom elements

eg:
 <anyelement *ngFor="condition">

 <div *ngFor="let variableName of arrayname">
       {{VariableName.property}}
 </div>
 This code will create more div elements

 <app-item-list *ngFor="">
Static view:
<ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>

    </ul>

<div>
    <h1 style="text-align: center;">For loop</h1>

    <!--ul element-->
    <ul>
        <li *ngFor="let i of numbers">{{i}}</li>
    </ul>
    <!--Ui element for tod-->
    <ul class="list-group">
        <li class="list-group-item d-flex justify-content-between align-items-center" *ngFor="let todo of todos">
            <span class="badge badge-primary badge-pill"> {{todo.id}} </span> {{todo.title}}
        </li>

    </ul>
    <div class="card" *ngFor="let todo of todos">
        <h5 class="card-header">{{todo.id}}</h5>
        <div class="card-body">
            <h5 class="card-title">{{todo.userId}}</h5>
            <p class="card-text">{{todo.title}}</p>
            <a href="#" class="btn btn-primary">Update</a>
        </div>
    </div>
</div>

////////////////////////////////////////////////////////////////////////////////////////////


*ngIf : add or remove dom element based on boolean condtion

if...else:

  <!--if else lader-->

    <div *ngIf="isEnabled; else mycondition">
        <h1>You have Facility!</h1>
    </div>

   <ng-template #mycondition>
      <h1>Sorry! Facility is not availbale</h1>
   </ng-template>

# : template reference variable

<h2>Structural Directives : IF</h2>
<div *ngIf="isHidden">
    <h1>Hello</h1>
</div>
<h2>Structural Directives : IF..else</h2>
<div *ngIf="isEnabled; else mycondition">
    <h1>You have Facility!</h1>
</div>

<ng-template #mycondition>
    <h1>Sorry! Facility is not availbale</h1>
</ng-template>

<h2>Structural Directives : IF..else :Progress Bar</h2>
<h2>
    <div *ngIf="loading; else notLoading  ">
        <h2>{{status}}</h2>
    </div>
</h2>
<ng-template #notLoading>
    <div>
        <h2>{{status}}</h2>
    </div>
</ng-template>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-if',
  templateUrl: './if.component.html',
  styles: [
  ]
})
export class IfComponent implements OnInit {
  isHidden:boolean = true
  isEnabled:boolean =false;
  loading:boolean  =false;
  status:string = "loading....."

  constructor() { 
     setTimeout(()=>{
       this.loading =  true;
       this.status = "Hello,Data is available"
     },5000)

  }

  ngOnInit(): void {
  }

}
..............................................................................................

The problem with *ngIf

-removes elements if condition is false, add element if condtion is true.

if do we this dynamically in big application which impact performance.

Recommended  is "hidden" attribute

<h2>Show and Hide using hidden attribute</h2>
<button class="btn btn-success" (click)="toggle()">Toggle</button>
<!--Show and Hide-->
<!-- <div *ngIf="isHidden">
    <h1>Hello</h1>
</div> -->
<div [hidden]="isHidden">
    <h1>Hai</h1>
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-if',
  templateUrl: './if.component.html',
  styles: [
  ]
})
export class IfComponent implements OnInit {
  isHidden: boolean = true
  
  ngOnInit(): void {
  }
  toggle() {
    this.isHidden = !this.isHidden;
  }

}
..............................................................................................

Switch case:

Switch case:

<div class="container">
    <h1 style="text-align: center;">Swich case </h1>
    <input [(ngModel)]="input">
    <button (click)="showFeedback()">Show Feedback</button>

    <div [ngSwitch]="feedback">
        <p *ngSwitchCase="'good'">Good</p>
        <p *ngSwitchCase="'verygood'">Very Good</p>
        <p *ngSwitchCase="'bad'">Bad</p>
        <p *ngSwitchDefault>Your input is not matching</p>
    </div>
    <div [ngSwitch]="feedback">
        <ng-template [ngSwitchCase]="'good'">
            <h3>Good</h3>
        </ng-template>
        <ng-template [ngSwitchCase]="'verygood'">
            <h3>Very Good</h3>
        </ng-template>
        <ng-template [ngSwitchCase]="'bad'">
            <h3>bad</h3>
        </ng-template>
        <ng-template ngSwitchDefault>
            <h3>Your input is not matching</h3>
        </ng-template>
    </div>

</div>

export class SwitchcaseComponent implements OnInit {

  feedback: string = "good"
  input:string ="";
  constructor() { }

  ngOnInit(): void {
  }
  showFeedback() {
    this.feedback = this.input
  }

}
..............................................................................................
					Attribute Directive
..............................................................................................

///////////////////////////////////////////////////////////////////////////////////////////////////

3.Attribute directive :

 Adding extra behaviour to existing dom elements.

eg:
 <div subu="">

 <div appHighlight>

How to create our own attribute directive.

Steps:

1.declare directive class and decorate it

import { Directive } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  constructor() { 
    console.log('directive is applied')
  }

}

Syntax
-app=>root prefix
-Highlight - Name of the Directive

now you can apply this on any dom element as attribute

 <h1 appHighlight >Hello</h1>

2.DI inisde any modules- app

declarations: [HighlightDirective]

//////////////////////////////////////////////////////////////////////////////////////////////
				 DOM MANIPULATION
..............................................................................................


Access Object , change its values

 h2------Object---->change its value

Using js you change it.

 var element = document.getElementByid('xxx')



Ways of dom manipulation:

1.via structural directive -*ngFor,*ngIf

2.via $event object.

3.Javascript way
   access dom element directly like js inside angular via attribute directive.

AttributeDirecive is object through which you can access native dom elements and do dom maniuplation.

1.INSIDE Directive
  using "ElementRef" -Object
A wrapper around a native element inside of a View.

this.element.nativeElement.style.backgroundColor = "yellow";

How to use ElementRef object?
  
Angular is di framework, you have to grab any object inside another via constructors.

    this.element.nativeElement.style.backgroundColor = 'yellow'

How to add event listeners and events?
  js way.

////////////////////////////////////////////////////////////////////////////////////

import { Directive, ElementRef, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  constructor(private element: ElementRef) {
    console.log('directive is applied')
    console.log(this.element.nativeElement)
    //setting back ground color
    this.element.nativeElement.style.backgroundColor = 'yellow'
  }
  @HostListener('mouseenter')
  onMouseEnter() {
    console.log('entering')
    this.highLight('yellow')
  }
  @HostListener('mouseleave')
  onMouseLeave() {
    console.log('leaving')
    this.highLight(null)

  }
  private highLight(color: string) {
    this.element.nativeElement.style.backgroundColor = color

  }

}

inside component:
<div>
    <h1 appHighlight >Highlight Me!</h1>
</div>

/////////////////////////////////////////////////////////////////////////////////////////////

How to pass input to the attribute directive, so that dynamically we can apply changes?

Via @input



<div>
    <h2>Pick a Color</h2>
    <div>
        <input type="radio" name="colors" (click)="color='lightgreen'">Green
        <input type="radio" name="colors" (click)="color='yellow'">Yellow
        <input type="radio" name="colors" (click)="color='brown'">Brown

    </div>

    <h1 [appHighlight]="color">Attribute Directive</h1>
</div>

import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  @Input()
  appHighlight: string;

  constructor(private element: ElementRef) {
    // console.log('directive is applied')
    // console.log(this.element.nativeElement)
    // //setting back ground color
    // this.element.nativeElement.style.backgroundColor = 'yellow'
  }
  @HostListener('mouseenter')
  onMouseEnter() {
    console.log('entering', this.appHighlight)
    // this.highLight('yellow')
    this.highLight(this.appHighlight)
  }
  @HostListener('mouseleave')
  onMouseLeave() {
    console.log('leaving')
    this.highLight(null)

  }
  private highLight(color: string) {
    this.element.nativeElement.style.backgroundColor = color

  }

}
..............................................................................................
				  Services
.............................................................................................
































